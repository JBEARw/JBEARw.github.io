{"meta":{"title":"WBearJ的博客","subtitle":null,"description":null,"author":"JBEARw","url":"http://wbear.top"},"pages":[{"title":"关于","date":"2017-11-03T06:36:17.000Z","updated":"2017-11-03T06:36:31.000Z","comments":true,"path":"about/index.html","permalink":"http://wbear.top/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-11-03T06:33:29.000Z","updated":"2017-11-03T06:34:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://wbear.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-11-03T06:35:08.000Z","updated":"2017-11-03T06:35:37.000Z","comments":true,"path":"categories/index.html","permalink":"http://wbear.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS LLVM Clang初探","slug":"iOS-LLVM-Clang","date":"2017-11-10T16:00:00.000Z","updated":"2017-11-23T09:29:26.800Z","comments":true,"path":"2017/11/11/iOS-LLVM-Clang/","link":"","permalink":"http://wbear.top/2017/11/11/iOS-LLVM-Clang/","excerpt":"平时在日常开发过程中经常能在调试信息中看到LLVM以及Clang字符，于是我就产生了疑惑，LLVM以及Clang到底是什么，为什么会在编译器的调试信息中出现?并且为什么能够精准的定位错误？","text":"平时在日常开发过程中经常能在调试信息中看到LLVM以及Clang字符，于是我就产生了疑惑，LLVM以及Clang到底是什么，为什么会在编译器的调试信息中出现?并且为什么能够精准的定位错误？ 首先LLVM其实是编译器的基础设施，提供了其相关支持，可以作为多种语言编译器的后台使用。而Clang则是基于LLVM编译器工具集的前端：目的是为了输出代码对应的抽象语法树（Abstract Syntax Tree， AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。 在性能方方面Clang编译的Objective-C代码时运行速度是GCC的三倍，还能针对用户发生的编译错误准确的给出建议(看来这就是我想要的！) 首先我们先举一个例子:1234$ cat test.cint foo(int x, pid_t y) &#123; return x+y;&#125; 123456$ time clang text.ctest.c:1:16: error: unknown type name 'pid_t'int foo(int x, pid_t y) &#123; ^1 error generated.clang test.c 0.01s user 0.28s system 77% cpu 0.382 total 可以看到Clang精准的定位到了错误位置并指出了错误原因，通过查阅资料发现了clang中parser的错误处理机制——则是其能准确定位的原因。 现在既然知道原因了，我们就可以开始分析一下错误处理的流程了。 当程序进入编译阶段时，首先编译器会去寻找关键字–”括号”(如果有兴趣可以了解下源码)当发现关键字以后，编译器则开始排查错误了，这时候我们接着往下看。12/// Diagnose brackets before an identifier.void Parser::ParseMisplacedBracketDeclarator(Declarator &amp;D)12SourceLocation StartBracketLoc = Tok.getLocation();Declarator TempDeclarator(D.getDeclSpec(), D.getContext()); 编译器则先会记录文件位置，之后就开始调用错误检查以及错误恢复方法。具体错误检查以及错误恢复的语法在这个文件里。12345678910111213141516171819if (TempDeclarator.getNumTypeObjects() == 0) return; // Determine if parens will need to be suggested in the diagnostic. bool NeedParens = false; if (D.getNumTypeObjects() != 0) &#123; switch (D.getTypeObject(D.getNumTypeObjects() - 1).Kind) &#123; case DeclaratorChunk::Pointer: case DeclaratorChunk::Reference: case DeclaratorChunk::BlockPointer: case DeclaratorChunk::MemberPointer: NeedParens = true; break; case DeclaratorChunk::Array: case DeclaratorChunk::Function: case DeclaratorChunk::Paren: break; &#125; &#125; 这里大概能明白个7，8分了，我们在回头看一下解析错误的方法。123456789101112131415161718192021void Parser::ParseNullabilityTypeSpecifiers(ParsedAttributes &amp;attrs) &#123; // Treat these like attributes, even though they're type specifiers. while (true) &#123; switch (Tok.getKind()) &#123; case tok::kw__Nonnull: case tok::kw__Nullable: case tok::kw__Null_unspecified: &#123; IdentifierInfo *AttrName = Tok.getIdentifierInfo(); SourceLocation AttrNameLoc = ConsumeToken(); if (!getLangOpts().ObjC1) Diag(AttrNameLoc, diag::ext_nullability) &lt;&lt; AttrName; attrs.addNew(AttrName, AttrNameLoc, nullptr, AttrNameLoc, nullptr, 0, AttributeList::AS_Keyword); break; &#125; default: return; &#125; &#125;&#125; 可以看到所谓的错误恢复机制就是发现错误后，调用本身存在的错误信息库进行比对–一个一个的进行解析比对。然后在尝试恢复错误，如果遇到库中匹配的则会返回具体的错误消息。 所以Clang之所以能够准确的定位错误以及提供错误修正方法完全是因为人力堆起来的错误数据库(这样就是各位大佬人肉费时费力堆起来的)。目前水平有限，也只能理解到这个程度了。如果上面有什么不对的地方，欢迎大家及时指出。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://wbear.top/categories/iOS/"}],"tags":[{"name":"LLVM Clang","slug":"LLVM-Clang","permalink":"http://wbear.top/tags/LLVM-Clang/"}]},{"title":"开始","slug":"开始","date":"2017-11-01T16:00:00.000Z","updated":"2017-11-02T07:23:00.000Z","comments":true,"path":"2017/11/02/开始/","link":"","permalink":"http://wbear.top/2017/11/02/开始/","excerpt":"Start 本来搭建blog的事情是从去年就开始弄了，结果因为某些原因(就是懒)一直搁置。但是现在一个差不多样子的网站算是搭起来了，所以说也算是一个开始。","text":"Start 本来搭建blog的事情是从去年就开始弄了，结果因为某些原因(就是懒)一直搁置。但是现在一个差不多样子的网站算是搭起来了，所以说也算是一个开始。 其实起因也是因为这半年的工作状态的原因吧。从APP端业务被停止之后，写了半年的web端，工作任务一下变的轻松无比。人是一种有惰性的生物，所以这半年现在回想起来完全是浪费了半年的时间，这一点在找工作的时候显得更为明显。学如逆水行舟、不进则退，古人的智慧不容小觑，所以在上个月选择了主动离职。当时的压力很大，房贷、装修、结婚…所有的事情都挤在了一块，在这个时候给我最大支持的还是自己的媳妇，我也是在这个时候看清了自己的现状。 现在选择搭建起blog的原因也很简单:改变自己的惰性、锻炼自己的语言组织能力…作为开始写的也有点多了，之前牺牲了太多时间在游戏上面，现在则是需要把这些浪费的时间一点一点找回来。 ​","categories":[{"name":"other","slug":"other","permalink":"http://wbear.top/categories/other/"}],"tags":[{"name":"start","slug":"start","permalink":"http://wbear.top/tags/start/"}]}]}