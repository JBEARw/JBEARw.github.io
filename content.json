{"meta":{"title":"WBearJ的博客","subtitle":null,"description":null,"author":"JBEARw","url":"http://wbear.top"},"pages":[{"title":"标签","date":"2017-11-03T06:33:29.000Z","updated":"2017-11-03T06:34:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://wbear.top/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-11-03T06:36:17.000Z","updated":"2017-11-03T06:36:31.000Z","comments":true,"path":"about/index.html","permalink":"http://wbear.top/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-11-03T06:35:08.000Z","updated":"2017-11-03T06:35:37.000Z","comments":true,"path":"categories/index.html","permalink":"http://wbear.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"如何机智的使用断点调试","slug":"如何机智的使用断点调试","date":"2017-11-24T16:00:00.000Z","updated":"2018-03-17T14:58:19.832Z","comments":true,"path":"2017/11/25/如何机智的使用断点调试/","link":"","permalink":"http://wbear.top/2017/11/25/如何机智的使用断点调试/","excerpt":"断点调试是我们在日常开发中使用最多的手段，在程序某一个位置打上断点来一步一步跟踪程序执行的流程，根据变量的值来找到程序的bug。 首先我们要知道Xcode内置的调试器是LLDB(Xcode5前的调试器是GDB，有兴趣的可以了解一下)，它和LLVM编译器一起来帮助开发者进行更精准的流程控制以及调试功能。","text":"断点调试是我们在日常开发中使用最多的手段，在程序某一个位置打上断点来一步一步跟踪程序执行的流程，根据变量的值来找到程序的bug。 首先我们要知道Xcode内置的调试器是LLDB(Xcode5前的调试器是GDB，有兴趣的可以了解一下)，它和LLVM编译器一起来帮助开发者进行更精准的流程控制以及调试功能。 首先在调试界面我们会看到下面按钮:然后在调试按钮下方会有一列参数:Tips:在我们需要观察一个变量变化情况的时候只需要点击’watch’选项就可以监视其变化以上则是平常比较常用的可视化的调试功能。现在让我们回到LLDB本身的调试指令，我们在调试控制台里使用指令来帮助我们更方便的调试程序(在控制台中输入-help，则会展示出所有的指令以及意义) 在这里我们来分析一些比较常用的指令 po指令 po指令是在调试中最常使用的指令，在断点状态下在控制台输入 po 则会打印出any的具体内容 image指令 这个是很重要但是平常很少人会使用的一个指令，我觉得这个指令在平常调试中是很实用的一个指令，如果我在一个地方写上这样的一段代码则程序会crash，控制台会打印以下信息: Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘ -[__NSArrayI objectAtIndexedSubscript:]: index 2 beyond bounds [0 .. 1]’ First throw call stack:( 0 CoreFoundation 0x00000001073bd12b exceptionPreprocess + 171 1 libobjc.A.dylib 0x0000000106a51f41 objc_exception_throw + 48 2 CoreFoundation 0x00000001073fd0cc _CFThrowFormattedException + 194 3 CoreFoundation 0x0000000107470890 +[NSArrayI allocWithZone:] + 0 4 breakpointDemo 0x000000010614564e -[ViewController viewDidLoad] + 174 5 UIKit 0x00000001079e346c -[UIViewController loadViewIfRequired] + 1235 6 UIKit 0x00000001079e38b9 -[UIViewController view] + 27 7 UIKit 0x00000001078ae7cf -[UIWindow addRootViewControllerViewIfPossible] + 122 8 UIKit 0x00000001078aeed7 -[UIWindow _setHidden:forced:] + 294 9 UIKit 0x00000001078c1e54 -[UIWindow makeKeyAndVisible] + 42 10 UIKit 0x00000001078348b8 -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 4737 11 UIKit 0x0000000107839aeb -[UIApplication _runWithMainScene:transitionContext:completion:] + 1720 12 UIKit 0x0000000107c036f8 111-[UICanvasLifecycleMonitor_Compatability _scheduleFirstCommitForScene:transition:firstActivation:completion:]_block_invoke + 924 13 UIKit 0x0000000107fd94c8 +[_UICanvas _enqueuePostSettingUpdateTransactionBlock:] + 153 14 UIKit 0x0000000107c032f1 -[UICanvasLifecycleMonitor_Compatability _scheduleFirstCommitForScene:transition:firstActivation:completion:] + 249 15 UIKit 0x0000000107c03b6b -[UICanvasLifecycleMonitor_Compatability activateEventsOnly:withContext:completion:] + 696 16 UIKit 0x0000000108581a69 82-[_UIApplicationCanvas _transitionLifecycleStateWithTransitionContext:completion:]_block_invoke + 262 17 UIKit 0x0000000108581922 -[_UIApplicationCanvas _transitionLifecycleStateWithTransitionContext:completion:] + 444 18 UIKit 0x000000010825e9c8 125-[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:withUpdatedScene:settingsDiff:fromSettings:transitionContext:]_block_invoke + 221 19 UIKit 0x000000010845db06 _performActionsWithDelayForTransitionContext + 100 20 UIKit 0x000000010825e88b -[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:withUpdatedScene:settingsDiff:fromSettings:transitionContext:] + 231 21 UIKit 0x0000000107fd8b25 -[_UICanvas scene:didUpdateWithDiff:transitionContext:completion:] + 392 22 UIKit 0x000000010783836a -[UIApplication workspace:didCreateScene:withTransitionContext:completion:] + 523 23 UIKit 0x0000000107e13605 -[UIApplicationSceneClientAgent scene:didInitializeWithEvent:completion:] + 369 24 FrontBoardServices 0x000000010bb0acc0 -[FBSSceneImpl _didCreateWithTransitionContext:completion:] + 338 25 FrontBoardServices 0x000000010bb137b5 56-[FBSWorkspace client:handleCreateScene:withCompletion:]_block_invoke_2 + 235 26 libdispatch.dylib 0x000000010ad6933d _dispatch_client_callout + 8 27 libdispatch.dylib 0x000000010ad6e9f3 _dispatch_block_invoke_direct + 592 28 FrontBoardServices 0x000000010bb3f498 FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK + 24 29 FrontBoardServices 0x000000010bb3f14e -[FBSSerialQueue _performNext] + 464 30 FrontBoardServices 0x000000010bb3f6bd -[FBSSerialQueue _performNextFromRunLoopSource] + 45 31 CoreFoundation 0x0000000107360101 CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION + 17 32 CoreFoundation 0x00000001073fff71 CFRunLoopDoSource0 + 81 33 CoreFoundation 0x0000000107344a19 CFRunLoopDoSources0 + 185 34 CoreFoundation 0x0000000107343fff CFRunLoopRun + 1279 35 CoreFoundation 0x0000000107343889 CFRunLoopRunSpecific + 409 36 GraphicsServices 0x000000010c3d39c6 GSEventRunModal + 62 37 UIKit 0x000000010783b5d6 UIApplicationMain + 159 38 breakpointDemo 0x000000010614575f main + 111 39 libdyld.dylib 0x000000010ade5d81 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException在这么一大串的信息中找到错误位置其实挺麻烦的，这时我们可以使用image指令来帮助我们找到具体的错误位置。首先大概浏览一下错误信息可以发现是在第4个信息是导致crash的原因，记录下地址0x000000010614564e，然后我们在控制台输入image lookup --address &lt;address&gt;可以看到:1234(lldb) image lookup --address 0x000000010614564e Address: breakpointDemo[0x000000010000164e] (breakpointDemo.__TEXT.__text + 174) Summary: breakpointDemo`-[ViewController viewDidLoad] + 174 at ViewController.m:21(lldb) 可以很明显的看到错误位置——是在ViewController中的.m文件里的21行。这两个我是平常用的比较多的指令，其他如果有什么更加厉害的指令——请告诉我，我会虚心的学习:) 然后让我们在回到断点本身，断点在开发中也是分不同类型的断点的，比如以下类型: 全局断点 有时候在程序发生crash的时候，程序会定位到main函数里，控制台也是没有任何信息…像这种我们就可以使用全局断点来找到出错的栈低信息 条件断点 这个比起上面的全局断点，这个可要更加的厉害了，下面举几个例子大家看的就比较明显了。首先我们看下下面的代码然后我们右键点击断点条，选择Edit Breakpoint...然后在condition中输入我们想要的条件这样只有在a == 20的时候才会触发这个断点(不一定是数字，其他类型也可以作为触发条件)，当然我们也可以使用condition下面的ignore功能，比如我们想在10次的时候出发断点，则在ignore的值改成10就可以了。 下面一个例子:我们在这里使用另外一个全局断点，然后在symbol中输入viewWillAppear条件，则在程序运行中只要是运行到了函数名为viewWillAppear的时候就会触发断点。 这里我们就可以拓展一下，我们在开发中会遇到unrecognized selector sent to instance &lt;address&gt;这种错误，这个我们就可以使用-[NSObject(NSObject) doesNotRecognizeSelector:]条件来定位到具体位置。 以上就是目前比较常用的调试方式，如果后期遇到其他黑科技，我也会回来更新的！","categories":[{"name":"iOS","slug":"iOS","permalink":"http://wbear.top/categories/iOS/"}],"tags":[{"name":"断点","slug":"断点","permalink":"http://wbear.top/tags/断点/"}]},{"title":"where and how?如何正确的使用单例！","slug":"where？when-and-how-如何正确的使用单例！","date":"2017-11-17T16:00:00.000Z","updated":"2018-03-12T13:52:16.144Z","comments":true,"path":"2017/11/18/where？when-and-how-如何正确的使用单例！/","link":"","permalink":"http://wbear.top/2017/11/18/where？when-and-how-如何正确的使用单例！/","excerpt":"","text":"单例在日常工作中应该算是使用频率较高的一种模式，但是我们在使用过程中也有很多需要注意的地方—— 我们应该在什么地方使用单例？ 我们应该如何使用单例？首先我们先了解单例是一种怎样的模式和有什么样的优缺点。优点： 在程序的生命中期中单例有且只会创建一次. 对于一些经常需要创建和销毁的对象，单例可以减少系统的开销.缺点： 太多单例会加重内存的负荷. 在多人项目中，开发人员必须要注意单例对象不能在其他地方新建(new)。 单例没有抽象层，因此单例的扩展有很大的困难。 一般情况下我们会把User对象存为单例，因为在应用程序中如果不进行注销行为的话，User是始终存在于APP整个生命周期的。同理例如-网络请求，音乐播放器等。 目前能理解的比较浅，能写的也比较少，以后遇到相应问题在回来更新","categories":[{"name":"iOS","slug":"iOS","permalink":"http://wbear.top/categories/iOS/"}],"tags":[{"name":"单例","slug":"单例","permalink":"http://wbear.top/tags/单例/"}]},{"title":"iOS LLVM Clang初探","slug":"iOS-LLVM-Clang","date":"2017-11-10T16:00:00.000Z","updated":"2018-03-12T13:51:24.235Z","comments":true,"path":"2017/11/11/iOS-LLVM-Clang/","link":"","permalink":"http://wbear.top/2017/11/11/iOS-LLVM-Clang/","excerpt":"平时在日常开发过程中经常能在调试信息中看到LLVM以及Clang字符，于是我就产生了疑惑，LLVM以及Clang到底是什么，为什么会在编译器的调试信息中出现?并且为什么能够精准的定位错误？","text":"平时在日常开发过程中经常能在调试信息中看到LLVM以及Clang字符，于是我就产生了疑惑，LLVM以及Clang到底是什么，为什么会在编译器的调试信息中出现?并且为什么能够精准的定位错误？ 首先LLVM其实是编译器的基础设施，提供了其相关支持，可以作为多种语言编译器的后台使用。而Clang则是基于LLVM编译器工具集的前端：目的是为了输出代码对应的抽象语法树（Abstract Syntax Tree， AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。 在性能方方面Clang编译的Objective-C代码时运行速度是GCC的三倍，还能针对用户发生的编译错误准确的给出建议(看来这就是我想要的！) 首先我们先举一个例子:1234$ cat test.cint foo(int x, pid_t y) &#123; return x+y;&#125; 123456$ time clang text.ctest.c:1:16: error: unknown type name 'pid_t'int foo(int x, pid_t y) &#123; ^1 error generated.clang test.c 0.01s user 0.28s system 77% cpu 0.382 total 可以看到Clang精准的定位到了错误位置并指出了错误原因，通过查阅资料发现了clang中parser的错误处理机制——则是其能准确定位的原因。 现在既然知道原因了，我们就可以开始分析一下错误处理的流程了。 &lt;img src=&quot;http://wbearjimg.oss-cn-shenzhen.aliyuncs.com/iOS/clang.png&quot;/&gt; 当程序进入编译阶段时，首先编译器会去寻找关键字–”括号”(如果有兴趣可以了解下源码)当发现关键字以后，编译器则开始排查错误了，这时候我们接着往下看。 12/// Diagnose brackets before an identifier.void Parser::ParseMisplacedBracketDeclarator(Declarator &amp;D) 12SourceLocation StartBracketLoc = Tok.getLocation();Declarator TempDeclarator(D.getDeclSpec(), D.getContext()); 编译器则先会记录文件位置，之后就开始调用错误检查以及错误恢复方法。具体错误检查以及错误恢复的语法在这个文件里。 12345678910111213141516171819if (TempDeclarator.getNumTypeObjects() == 0) return; // Determine if parens will need to be suggested in the diagnostic. bool NeedParens = false; if (D.getNumTypeObjects() != 0) &#123; switch (D.getTypeObject(D.getNumTypeObjects() - 1).Kind) &#123; case DeclaratorChunk::Pointer: case DeclaratorChunk::Reference: case DeclaratorChunk::BlockPointer: case DeclaratorChunk::MemberPointer: NeedParens = true; break; case DeclaratorChunk::Array: case DeclaratorChunk::Function: case DeclaratorChunk::Paren: break; &#125; &#125; 这里大概能明白个7，8分了，我们在回头看一下解析错误的方法。 123456789101112131415161718192021void Parser::ParseNullabilityTypeSpecifiers(ParsedAttributes &amp;attrs) &#123; // Treat these like attributes, even though they're type specifiers. while (true) &#123; switch (Tok.getKind()) &#123; case tok::kw__Nonnull: case tok::kw__Nullable: case tok::kw__Null_unspecified: &#123; IdentifierInfo *AttrName = Tok.getIdentifierInfo(); SourceLocation AttrNameLoc = ConsumeToken(); if (!getLangOpts().ObjC1) Diag(AttrNameLoc, diag::ext_nullability) &lt;&lt; AttrName; attrs.addNew(AttrName, AttrNameLoc, nullptr, AttrNameLoc, nullptr, 0, AttributeList::AS_Keyword); break; &#125; default: return; &#125; &#125;&#125; 可以看到所谓的错误恢复机制就是发现错误后，调用本身存在的错误信息库进行比对–一个一个的进行解析比对。然后在尝试恢复错误，如果遇到库中匹配的则会返回具体的错误消息。 所以Clang之所以能够准确的定位错误以及提供错误修正方法完全是因为人力堆起来的错误数据库(这样就是各位大佬人肉费时费力堆起来的)。目前水平有限，也只能理解到这个程度了。如果上面有什么不对的地方，欢迎大家及时指出。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://wbear.top/categories/iOS/"}],"tags":[{"name":"LLVM Clang","slug":"LLVM-Clang","permalink":"http://wbear.top/tags/LLVM-Clang/"}]},{"title":"开始","slug":"开始","date":"2017-11-01T16:00:00.000Z","updated":"2018-03-17T07:52:31.223Z","comments":true,"path":"2017/11/02/开始/","link":"","permalink":"http://wbear.top/2017/11/02/开始/","excerpt":"Start 本来搭建blog的事情是从去年就开始弄了，结果因为某些原因(就是懒)一直搁置。但是现在一个差不多样子的网站算是搭起来了，所以说也算是一个开始。","text":"Start 本来搭建blog的事情是从去年就开始弄了，结果因为某些原因(就是懒)一直搁置。但是现在一个差不多样子的网站算是搭起来了，所以说也算是一个开始。 其实起因也是因为这半年的工作状态的原因吧。从APP端业务被停止之后，写了半年的web端，从零开始学习前端-HTML5、CSS、JS。大概花了一月的时间就已经单独开始书写界面了。之前在简书维护的账号目前也停掉了，现在开始维护目前的这个blog，开始把以前的知识点梳理之后在往新家里一点一点搬。前段时间也是人生的大事都凑在一块了，买房、结婚、装修… 精力有点透支，目前只能一点一点的来完成之前定下的目标。 这个blog其实是用来给自己记录一些工作上的知识点以及遇到的部分bug，毕竟人的大脑记忆力是有限的，一些知识点和遇到的问题过段时间说不定就会忘掉。好记性不如烂笔头——这句话不是完全没有道理的。 ​","categories":[{"name":"other","slug":"other","permalink":"http://wbear.top/categories/other/"}],"tags":[{"name":"start","slug":"start","permalink":"http://wbear.top/tags/start/"}]}]}